# 第十五章

## 测试

三，这是本书中专门讨论类型系统的章节数。

但我意识到，并不是 PHP 社区中的每个人都喜欢使用类型：有些人觉得它们太冗长，或者认为当你没有接受静态分析时，它们没有增加足够的价值。就我个人而言，我在"尝试对所有内容进行类型化"的阵营中，但我尊重其他意见。我认为在某些情况下，接受 PHP 的动态特性会更简单。

不过，本章不会讨论类型。它是关于测试的，那么我为什么再次提到类型？我之前提到，类型减少了你应该编写的测试数量，仍然能够知道程序正确工作。你可以将类型视为它们自己的迷你测试：内置到语言中以确保你的代码正确工作。

然而，类型不可能涵盖所有业务逻辑，这就是为什么适当的测试套件仍然有其用途。

测试作为工作流程的组成部分，可以回答一些问题：

什么类型的测试更好？应该使用哪个测试框架？我不会给出任何明确的答案。但是，我们将在本章中一起探索一些选项，并讨论什么构成了一个好的测试套件。我无意在本章中给你一个关于测试框架或测试策略的分步指南。相反，我想向你展示不同的选项。

## 测试类型

有单元测试、集成测试、验收测试、变异测试等等。我认为可能很难知道从哪里开始。

有些人可能会说单元测试是正确的方法，而其他人会告诉你一个集成测试值得一千个单元测试。反过来，这个论点被反驳，因为集成测试在不应该中断时容易中断。那么，对你来说最好的选择是什么？

## 单元测试 vs 集成测试？

单元测试的定义是它应该孤立地测试程序的"单元"或"组件"。这种隔离通常通过模拟依赖来实现，这样如果这些依赖内部发生变化，单元测试就不会中断。使用模拟会带来额外的维护成本。还有一个问题是"单元"有多大：是函数、类、模块？

另一方面，集成测试旨在将一组单元作为一个整体进行测试。

它们代表更接近现实生活的场景，例如用户提交表单及其所有副作用，或每小时运行的 cron 作业。集成测试将测试组件如何协同工作。

测试是一个非常谨慎的平衡游戏。即使你有 100% 的单元测试覆盖率，

仍然可能存在各个组件如何协同工作或传递某些输入时的 bug。另一方面，如果你只依赖集成测试，你将很难维护测试套件：它更庞大，在对代码库进行更改时容易中断，并且总体上慢得多。

与其从理论角度处理这个问题，让我们尝试以另一种方式解决它：我们测试套件的目标是什么？当然，它是测试程序是否正常工作，但还有更多。一个好的测试套件的一个特征是它可以随着你的项目而发展和增长。它是多功能的。我遇到过没有这种多功能性质的测试套件：从适当的测试套件开始的项目，结果发现它们在几个月后由于维护和代码腐烂而枯萎并被忽略。一旦我们放弃测试套件，大部分希望就失去了。所以最重要的是，你需要一个可以发展和灵活的测试套件，否则，它会很快失去价值。

如果你正在构建一个类似 CMS 的小型网站，你可能可以完全没有测试套件。但如果你在一个有数千行代码的代码库中与开发团队一起工作，你最终会遇到麻烦。对于任何人类来说，在大型代码库中进行更改并确保一切仍然正常工作，没有适当的测试套件是不可能的。迟早，你会在生产环境中部署 bug；

```php
大多数只会是小麻烦，但总有一天会出现那个灾难性的 bug，让你希望你的代码得到了适当的测试。

```

所以，找到一个可以随着你的项目而发展的测试策略。任何策略都比没有好。如果你和你的团队决定投资一个完全单元测试的项目，那很好，但要确保组件之间的流程也得到测试。如果你只投资集成测试，请准备好长期处理额外的维护成本，以及缓慢和庞大的测试套件。

我更喜欢在单元测试增加最大价值的地方使用单元测试。有最复杂决策逻辑但相对较少需要模拟的依赖的地方。领域代码通常是彻底单元测试套件的好候选者。广泛而快速的测试套件是多年来维护该代码的关键。另一方面，基础设施代码、控制器、路由、中间件、请求验证等，从一些健壮的集成测试中受益更好。我更喜欢像我的测试是最终用户或类似的东西一样测试这些代码片段。它允许你编写相对少量的测试，以便添加的性能成本相对较小。

## 更高一级

当我们上升一步，从单元测试到集成测试，我们的测试套件一次覆盖更多代码，运行通常更慢，更接近最终用户与我们的代码交互的方式。集成测试之上还有另一个级别。它再次更慢和更庞大，但也尽可能接近最终用户流程：验收测试。

有几种策略可以进行验收测试。我们都在使用至少一种形式：在发布之前手动点击应用程序；部署到生产环境之前的最后验证。有点讽刺的是，即使有完整的测试套件，我们仍然感到有必要进行一些手动测试，以确保一切对最终用户按预期工作。另一方面，这不应该太令人惊讶：我们的测试是用代码编写的，这不是最终用户与我们的程序交互的方式。开发人员如何测试和程序将如何使用之间总是存在差距。所以我们最终手动探索用户界面。有更好的解决方案。我们正在使用计算机，所以让它们完成所有这些工作；让我们自动化验收测试。

虽然关于单元测试和集成测试有很多选择和风格的测试框架，但没有很多选项可以模拟实际的用户行为。流行的 PHP 验收测试框架，如 Codeception 和 Dusk，都建立在相同的软件之上：Selenium。Selenium 是一个可以在任何给定浏览器中打开网页并做人类会做的任何事情：移动鼠标、点击按钮、

填写字段等。Selenium 本身是用 Java 编写的，但你可以通过 API 调用与它通信。有一个现有的 PHP 包也处理这个问题；它被称为 php-webdriver/php-webdriver。

想象一下可能性：编写模拟真实用户的脚本。以下是用 Dusk 编写的示例，它在底层使用 Selenium：

```php
$this=>browse(function ($first, $second) {
$first=>loginAs(User=:find(1))

```

          =>visit('/home')

```php
          =>waitForText('Message');
$second=>loginAs(User=:find(2))

```

           =>visit('/home')

           =>waitForText('Message')

           =>type('message', 'Hey')

```php
           =>press('Send');
$first=>waitForText('Hey')

          =>assertSee('Name');

});

```

可以自动化几乎所有我们否则会手动测试的东西。一方面，这是一项极好的投资，因为这样的测试大大减少了手动测试所花费的时间，但另一方面，这些测试更容易中断。想象一下更改按钮上的文本，或 Selenium 用于在页面上查找元素的类或 ID：我们的测试中断了。你可以添加特殊属性用作选择器，例如 data-selenium-login-button，

但这要求我们在 HTML 中编写大量额外的代码并管理它。

除此之外，这些测试比任何其他类型的测试都慢得多：Selenium 将在后台运行一个无头浏览器，需要启动并加载页面，而 Selenium 需要点击。当然，它比手动操作快得多，但与单元测试或集成测试相比，它们非常慢。再次，这是一个平衡游戏：在哪里使用 Selenium 测试，在哪里不使用？考虑到它们的维护成本和执行时间，它们在哪里增加足够的价值，在哪里不增加？根据我的经验，当你发现自己一遍又一遍地在 Web 浏览器中执行相同的手动测试时，最好使用 Selenium。Selenium 在测试时可能是一个很好的资产，例如，一个入职表单或一个重度 JavaScript 的前端工具。

## 测试测试

所以，我们有了：一个与我们的应用程序一起发展的平衡良好的测试套件——一切都很棒！不过，有一件事：我们如何知道我们的测试是否会测试正确的东西？我们如何知道我们正在测试所有相关代码？让我给你一个简化的例子：

```php
function specialFormat(string $input): string

{

    if ($input === 'a') {

        return str_repeat($input, 3);

    }

    return str_repeat($input, 5);

}

```

一个在现实生活中没有任何意义的例子，但现在让我们使用它。假设这是我们的测试：

```php
public function test_special_format()

{
$output = specialFormat('b');
$this=>assertEquals('bbbbb', $output);

}

```

它有效，测试成功，但我们错过了 'a' 边界情况！如果我们没有注意到这一点，我们的测试套件会给人一种虚假的安全感。由于现实生活中的代码比这个例子更复杂，我们很可能在这里和那里错过边界情况。

再次，我们可以使用我们的工具集来帮助我们，而不是试图自己管理一切。
其中一个工具内置在 phpunit 中：代码覆盖率分析。这样的分析器将在测试运行时查看我们的代码，注意哪些部分被执行，哪些部分没有执行。

它甚至可以显示未测试代码部分的逐行分析。这样的工具很棒，因为我们可以运行现有的测试套件，并返回一个百分比，说明我们的代码有多少被它覆盖。这是检测在测试期间未执行的代码的简单方法。

除了检测这些区域，我们还可以分析我们的测试是否万无一失。

这就是变异测试的用武之地。一个变异测试框架，如 Infection PHP，将多次运行我们的测试套件，但它在每次迭代中都会在源代码中改变小东西。这样的更改称为变异或突变体。推理是这样的：我们的测试套件应该足够有弹性，每当发生这样的变异时就会失败，因为一个存活的突变体（意味着它未被检测到，我们的测试仍然运行）

是我们测试套件中的潜在 bug。变异测试将改变小细节，例如将 < 更改为 == 或 ==，1 更改为 0，

instanceof 检查更改为 true 或 false 等。最后，我们得到一个报告，其中包含检测到代码库中更改的测试，以及没有检测到的测试。这会产生一个分数，

"变异分数指标"——简称 MSI。我们的 MSI 越高，检测到并杀死的突变体越多，表明测试套件越好。

我意识到关于我提到的框架和技术还有更多要说的，但这些超出了本书的范围。幸运的是，大多数项目都有很好的文档，

指导你完成技术设置并解释它们背后的思维方式。

最重要的是一个适合你项目的测试策略，一个在编码两个月后不会被忽略的策略。自动化测试对任何专业项目都非常有价值，所以你应该绝对投资它们：它们确实有回报！

