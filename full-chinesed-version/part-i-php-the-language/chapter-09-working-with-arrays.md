# 第九章

## 使用数组

我已经在前面的章节中使用了一些数组特定的语法，所以似乎应该专门花一些时间来讨论它们。现在不用担心：我不会讨论 PHP 中所有与数组相关的函数，它们太多了，这会相当无聊。不，我只讨论过去一年中数组和 PHP 语法使什么成为可能。在处理数组时添加了很多便利功能。

我们将在本章中讨论所有这些内容。

## 剩余和展开

你已经在之前的示例中看到了 ==. 运算符的两种用法：你可以使用它来"展开"数组元素并将它们单独传递给函数，以及创建可变函数，将参数的"剩余"部分收集到数组中。

让我们快速回顾一下。这里我们将数组元素展开到函数中：

```php
$data = ['a', 'b', 'c'];

function handle($a, $b, $c): void { /* … */ }

```

handle(==.$data);这里，我们使用可变函数，它收集剩余的参数并将它们存储在数组中。

```php
function handle($firstInput, ==.$listOfOthers) { /* … */ }

handle('a', 'b', 'c', 'd');

```

在这种情况下，$firstInput 将是 'a'，而 $listOfOthers 将是一个数组：

['b', 'c', 'd']。

关于可变函数的一个有趣的事情是，你也可以对它们进行类型提示，

所以你可以说传递给 $listOfOthers 的所有变量应该是，例如，

字符串：

```php
function handle($firstInput, string ==.$listOfOthers) { /* … */ }

```

你也可以将两者结合起来。这是任何类的静态构造函数的通用实现。它被包装在一个 trait 中，这样它就可以在你想要的任何类中使用。

```php
trait Makeable

{

    public static function make(==.$args): static

    {

        return new static(==.$args);

    }

}

```

在这个示例中，我们接受可变数量的输入参数，并将它们再次展开到构造函数中。这意味着，无论构造函数接受多少变量，我们都可以使用 make 将这些变量传递给它。以下是在实践中的样子：

```php
class CustomerData

{  

    use Makeable;

    public function =_construct(

        public string $name,

        public string $email,

        public int $age,

    ) {}

}
$customerData = CustomerData=:make($name, $email, $age);

```

// 或者你可以再次使用数组展开：

```php
$customerData = CustomerData=:make(==.$inputData);

```

关于数组展开还有一件事要提及：该语法也可以用于组合数组：

```php
$inputA = ['a', 'b', 'c'];
$inputB = ['d', 'e', 'f'];
$combinedArray = [==.$inputA, ==.$inputB];

```

// ['a', 'b', 'c', 'd', 'e', 'f']这是一种合并两个数组的简写方式。不过，有一个重要的注意事项：只有当输入数组只有数字键时，才允许使用这种数组内数组展开语法——不允许文本键。

## 数组解构

数组解构是从数组中提取元素的行为——它是关于将数组"解构"为单独的变量。你可以使用 list 或 [] 来这样做。

注意这个词是"destructure"（解构），而不是"destruction"（破坏）！

以下是它的样子：

```php
$array = [1, 2, 3]; 

```

// 使用 list 语法：

```php
list($a, $b, $c) = $array;

```

// 或简写语法：

```php
[$a, $b, $c] = $array;

```

// $a = 1

// $b = 2

// $c = 3 无论你更喜欢 list 还是其简写 [] 都取决于你。人们可能会争辩说 [] 

与简写数组语法有歧义，因此更喜欢 list。我将在代码示例中使用简写版本，因为这是我的偏好。我认为由于 [] 

符号在赋值运算符的左侧，很明显它不是数组定义。

所以让我们看看使用这种语法可以做什么。

## 跳过元素

假设你只需要数组的第三个元素；前两个可以通过简单地不提供变量来跳过。

```php
[, , $c] = $array;

```

// $c = 3 还要注意，对具有数字索引的数组进行数组解构将始终从索引 0 开始。以以下数组为例：

```php
$array = [

```

    1 => 'a',

    2 => 'b',

    3 => 'c',

```php
];

```

提取的第一个变量将是 null，因为没有索引为 0 的元素。

这可能看起来像是一个缺点，但幸运的是还有更多可能性。

## 非数字键

PHP 7.1 允许数组解构用于具有非数字键的数组。这允许更大的灵活性：

```php
$array = [

```

    'a' => 1,

    'b' => 2,

    'c' => 3,

```php
];

['c' => $c, 'a' => $a] = $array;

```

如你所见，你可以按任何顺序更改，也可以完全跳过元素。

## 实践

数组解构的用途之一是与 parse_url 和 pathinfo 等函数一起使用。

因为这些函数返回一个带有命名参数的数组，我们可以解构结果以提取我们想要的信息：

[
    'basename' => $file,
    'dirname' => $directory,

```php
] = pathinfo('/users/test/file.png');

```

你也可以在这个示例中看到，变量不需要与键相同的名称。但是，如果你正在解构一个具有未知键的数组，PHP 会发出通知：

[
    'path' => $path, 
    'query' => $query,

```php
] = parse_url('https:=/front-line-php.com');

```

// PHP Notice:  Undefined index: query 在这种情况下，$query 将是 null。你可以在示例中观察到最后一个细节：

命名解构允许尾随逗号，就像你习惯使用数组一样。

## 在循环中

数组解构还有更多用例——你已经在属性章节中看到了这个用法。你可以在循环中解构数组：

```php
$array = [

```

    [
        'name' => 'a',
        'id' => 1
    ],
    [
        'name' => 'b',
        'id' => 2
    ],

```php
];

foreach ($array as ['id' => $id, 'name' => $name]) {

```

    // …

```php
}

```

这在解析时可能很有用，例如，解析 JSON 或 CSV 文件。只是要小心，未定义的键仍然会触发通知。

所以这就是全部内容：你已经了解了在现代 PHP 中使用数组可以做的所有事情。我发现这些语法添加中的大多数都有它们的用例。

总有不依赖简写的其他方法来实现相同的结果

——这是你的选择。我们将在关于风格指南的章节中更多地讨论这些类型的偏好，但首先还有其他一些主题要讨论。

