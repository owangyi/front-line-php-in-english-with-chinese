# 第二章

## 新版本

由于本书旨在让你快速了解现代 PHP 实践，了解这门语言在过去十年左右发生了什么变化是很重要的。随着 PHP 7 的开发和发布，PHP 的格局发生了巨大变化。我喜欢将 PHP 7.x 版本视为这门语言的成熟阶段，所以我们将从这里开始。

首先，PHP 7.0 带来了显著的性能提升。PHP 大部分的核心被重写，这产生了明显的差异。仅仅通过使用 PHP 7 或更高版本，看到你的应用程序运行速度提高两到三倍并不罕见。

得益于 PHP 的核心价值观之一——保持向后兼容性——旧的 PHP 5 代码库可以轻松更新以从这些变化中受益。

## 版本 6 发生了什么？

PHP 5.6 是 5 系列的最新版本，下一个版本是 7.0。那么版本 6 发生了什么？核心团队开始开发它，但直到很晚才意识到内部实现存在重大问题。

他们决定再次重新设计引擎，但"PHP 6"已经在编写中了。为了避免混淆，他们决定跳过版本 6，直接跳到 PHP 7。

PHP 6 的故事已经成为社区内的传说。如果你想了解深入的故事，可以快速搜索一下 Google。尽管 PHP 7.0 是一个如此重要的里程碑，但到现在 PHP 还在继续前进。

PHP 7.0 已经被认为是旧版本了：它于 2015 年发布，五年后不再接收更新。大约在 5.x 后期版本，PHP 采用了严格的发布周期：每年发布一个新版本。大多数版本会得到两年的积极支持，随后是一年的额外安全支持。三年后，你应该更新，因为你使用的版本不再获得安全补丁。

可以说，跟随最新版本甚至更好。虽然总会有一些小的破坏性变更和弃用，但大多数代码可以轻松更新。

甚至还有出色的自动化工具，可以接收你现有的代码库，检测任何升级错误，并自动修复它们。

### 自动化

其中一个自动化工具叫做 Rector，这些年来它越来越受欢迎：https://github.com/rectorphp/rector。Rector 可以自动更新你的代码库，跨越多个 PHP 版本，如果你必须处理遗留项目，这是一个值得了解的好工具。

在接下来的几章中，我们将深入探讨 PHP 7 和 PHP 8 中添加的功能。在此之前，我们将从本章中较小但重要的变化开始。

## 尾随逗号

对尾随逗号的支持已经逐步添加到 PHP 8.0。它们现在在数组、函数调用、参数列表和闭包 use 语句中都受支持。

尾随逗号在开发者中是一个有些争议的话题。有些人喜欢它们；其他人讨厌它们。支持尾随逗号的一个论点是它们使差异更容易。例如，想象一个包含两个元素的数组：

```php
$array = [
$foo,
$bar

];
```

接下来你需要添加第三个：

```php
$array = [
$foo,
$bar,
$baz
];
```

像 GIT 这样的版本控制系统会列出两个更改而不是一个，因为你确实做了两个实际的更改。如果你总是使用尾随逗号，你就不需要修改现有行：

```php
$array = [
$foo,
$bar,
$baz,

];
```

除了版本控制差异之外，尾随逗号也可以被认为"更容易"推理，因为你永远不必担心是否添加额外的逗号。

你可能不喜欢这种写作风格，这没关系。我们将在后面的章节中讨论风格指南的重要性。

## 格式化数值

你可以使用下划线来格式化数值。这个下划线在解析代码时会被完全忽略，但使长数字更容易被人阅读。

这在测试中尤其有用。以下面的例子为例：我们正在测试发票流程，需要传入一个金额。将钱以分为单位存储是个好主意，以防止舍入错误，所以使用 _ 使其更清晰：

```php
public function test_create_invoice()

{
    // $100 and 10 cents

    $invoice = new Invoice(100_10);

    // Assertions
}

```

## 匿名类

匿名类在 PHP 7.0 中添加。它们可以用来即时创建对象；它们甚至可以扩展基类。以下是在测试上下文中的一个例子：

```php
public function test_dto_type_checking_with_arrays(): void
{
    $dto = new class(

        ['arrayOfInts' => [1, 2]]


    ) extends DataTransferObject {

        /** @var int[] */

        public array $arrayOfInts;

    }; 

    // Assertions
}    
```

## 灵活的 Heredoc

Heredoc 可以是处理较大字符串的有用工具，尽管它们在过去有一个烦人的缩进怪癖：你不能在结束分隔符前面有任何空格。实际上，这意味着你必须这样做：

```php
public function report(): void
{
    $query = <<<SQL SELECT * 
        FROM `table`
        WHERE `column` = true;
SQL;

}
```

幸运的是，你现在可以这样做：

```php
public function report(): void
{
    $query = <<<SQL SELECT * 
        FROM `table`
        WHERE `column` = true;

    SQL;
}
```

结束标记前面的空格将在所有行上被忽略。

## 异常改进

让我们看看 PHP 8 中的两个较小的添加。首先：throw 语句现在是一个表达式。这意味着你可以在更多地方使用它，例如空合并运算符的右操作数，或在短闭包中；我们稍后将深入介绍这两个功能。

```php
// Invalid before PHP 8

$name = $input['name'] ?? throw new NameNotFound();

// Valid as of PHP 8

$name = $input['name'] ?? throw new NameNotFound();
$error = fn (string $class) => throw new $class(); 

```

其次：异常支持非捕获的 catch。可能有些情况下，你想捕获异常以保持程序流程继续，但不对它做任何事情。你总是必须为捕获的异常分配一个变量，即使你不使用它。现在不再需要这样了：

```php
try {
    // Something goes wrong
} catch (Exception) {
    // Just continue
}
```

## 弱引用和映射

PHP 7.4 添加了弱引用的概念。要理解它们是什么，你需要了解一点关于垃圾收集的知识。每当创建一个对象时，它需要一些内存来跟踪其状态。如果创建了一个对象并将其分配给变量，那么该变量就是对该对象的引用。一旦不再有对对象的引用，它就不能被使用，将其保留在内存中也没有意义。这就是为什么垃圾收集器有时会寻找这些类型的对象并删除它们，释放内存。

弱引用是对对象的引用，不会阻止它们被垃圾收集。这个功能本身可能看起来有点奇怪，但从 PHP 8 开始，它们与弱映射结合使用，允许一个有趣的用例：使用弱引用引用的对象映射。

以 ORM 为例：它们经常实现缓存，这些缓存持有对实体类的引用，以提高实体之间关系的性能。只要这个缓存有对它们的引用，这些实体对象就不能被垃圾收集，即使缓存是唯一引用它们的东西。

如果这个缓存层改用弱引用和映射，PHP 将在没有其他东西引用它们时垃圾收集这些对象。特别是在 ORM 的情况下，它们可以在一个请求中管理数百甚至数千个实体；弱映射可以提供更好、更资源友好的方式来处理这些对象。

以下是弱映射的样子：

```php
class EntityCache 

{

    public function __construct(

        private WeakMap $cache

    ) {}

 

    public function getSomethingWithCaching(object $object): object

    {

        if (! isset($this->cache[$object])) {
$this->cache[$object] = $this

                ->computeSomethingExpensive($object);

        }

        return $this->cache[$object];

    }

    

```

    // …

```php
}

```

在这个例子中，我们将与对象相关的昂贵操作的结果缓存在缓存中。如果结果还不存在，我们将计算一次。由于弱映射，如果不再有其他引用，这个对象仍然可以被垃圾收集。

## The JIT

The JIT——即时编译器——是 PHP 8 中添加的核心机制，可以显著加速 PHP 代码。

JIT 编译器会在运行时查看代码，并尝试找到经常执行的那部分代码。编译器将获取这些部分并将它们编译为机器代码——即时编译——然后从那时起使用优化的机器代码。这种技术可以在像 JavaScript 这样的解释型语言中使用，现在也可以在 PHP 中使用。它有潜力显著提高应用程序的性能。

我说"潜力"是因为我们必须考虑一些注意事项。我将把这些以及所有其他与 JIT 相关的内容保留在专门讨论 JIT 的章节中。

## 对象上的类简写

::class 简写在 PHP 5.5 中添加，用于快速获取导入类的完整类名：

```php
$className = Offer::class;

```

在 PHP 8 中，这也适用于变量：

```php
$className = $offer::class;

```

## 改进的字符串到数字比较

PHP 动态类型系统的优势之一同时也是它的弱点之一：类型转换。当 PHP 遇到一段奇怪的代码时，它会尝试更改变量的类型。以下是一个比较字符串和数字的例子：

```
'1' == 1 // true 
```

如果你不想要这种类型转换，你可以使用三个 === 符号代替：

```
'1' === 1 // false 
```

然而，使用弱比较时有一些奇怪的边缘情况。以下在 PHP 8 之前的版本中返回 true：

```
'foo' == 1 // true
```

从 PHP 8 开始，这种行为得到了改进。上面的例子以及其他边缘情况现在会正确返回 false。

```
'foo' == 1 // false
```

## 错误控制运算符的变化

最后一个值得注意的变化是 @ 运算符不再抑制致命错误。你仍然可以使用它来抑制其他类型的错误，像这样：

```php
$file = @file_get_contents('none/existing/path');

```

在你不使用 @ 运算符的情况下，会触发错误，但使用 @ 时，$file 将简单地是 false。另一方面，如果在 PHP 8 中抛出致命错误，@ 运算符将不再忽略它。

## 核心深处

在 7.4 更新中，PHP 核心添加了两个底层组件：FFI 和预加载。这是两个复杂的主题，各自都有自己的章节。不过，我会在这里简要提及它们。

FFI——也称为外部函数接口——允许 PHP 直接与用例如 C 编写的共享库通信。换句话说：可以编写 PHP 扩展并将它们作为 composer 包分发，而无需安装底层 PHP 扩展本身。我保证我们很快就会深入探讨这个！

另一个——预加载——使你能在服务器启动时编译 PHP 代码。该代码将保留在内存中，供所有后续请求使用。它可以加速你的平均 PHP Web 框架，因为它不再需要在每个请求上启动。

再次：JIT 值得单独用一章来深入了解。

所以，把这些零散的小功能放在一边，让我们深入探讨过去几年添加到 PHP 的所有伟大功能！
