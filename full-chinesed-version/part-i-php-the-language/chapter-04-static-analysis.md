# 第四章

## 静态分析

在花费了整整一章讨论 PHP 的类型系统之后，我意识到我还没有讨论为什么你想要使用它。我意识到社区中有相当一部分人不喜欢使用 PHP 的类型系统，所以彻底讨论其优缺点是很重要的。

这就是我们在本章中要做的事情。我们将从讨论类型系统提供的价值开始。

许多人认为具有更严格类型系统的编程语言会有更少或没有运行时错误。有一个流行的说法是，强类型系统可以防止 bug，

但这并不完全正确。你仍然可以在强类型语言中轻松地写出 bug，但一系列 bug 不再可能发生，因为好的类型系统会阻止它们。

你是否不确定强类型、弱类型、静态类型和动态类型系统之间的区别？我们将在本章后面深入讨论这个话题！

想象一个简单的函数：rgbToHex。它接受三个参数，每个参数都是 0 到 255 之间的整数。该函数然后将这些整数转换为十六进制字符串。以下是不使用类型时这个函数的定义可能的样子：

```php
function rgbToHex($red, $green, $blue) {



    // …

}
```
由于我们想确保这个函数的实现是正确的，我们编写测试：

```php
assert(rgbToHex(0, 0, 0) === '000000');

assert(rgbToHex(255, 255, 255) === 'ffffff');

assert(rgbToHex(238, 66, 244) === 'ee42f4');

```

这些测试确保一切按预期工作。对吧？

嗯……我们只测试了 16,777,216 种可能的 RGB 组合中的三种。但逻辑推理告诉我们，如果这三个示例案例有效，我们可能是安全的。

但是，如果我们传递浮点数而不是整数会发生什么？

```php
rgbToHex(1.5, 20.2, 100.1);

```

或者超出允许范围的数字？

```php
rgbToHex(-504, 305, -59);

```

null 呢？

```php
rgbToHex(null, null, null);

```

或者字符串？

```php
rgbToHex('red', 'green', 'blue');

```

或者参数数量错误？

```php
rgbToHex();

rgbToHex(1, 2);

rgbToHex(1, 2, 3, 4);

```

或者以上几种情况的组合？

我可以轻松想到五个边界情况，我们需要在相对确定我们的程序能够完成它需要做的事情之前进行测试。这意味着我们至少需要编写八个测试，我相信你还能想出其他一些。这些就是类型系统旨在部分解决的问题，注意"部分"这个词，因为我们稍后会回到这个问题。如果我们通过特定类型过滤输入，我们的许多测试就会变得过时。假设我们只允许整数：

```php
function rgbToHex(int $red, int $green, int $blue) 

{

```

    // …

```php
}

```

你可以将类型视为所有可用输入的子类别；它是一个只允许特定项的过滤器。

让我们看看由于我们的 int 类型提示而不再需要的测试：

• 输入是否为数字

• 输入是否为整数

• 输入是否不为 null我们仍然需要检查输入数字是否在 0 到 255 之间。在这一点上，

我们遇到了许多类型系统（包括 PHP 的）的限制。当然我们可以使用 int，但在许多情况下，这种类型描述的类别对我们的业务逻辑来说仍然太大：int 也会允许传递 -100，这对我们的函数来说没有任何意义。一些语言有 uint 或"无符号整数"类型；但它仍然是"数值数据"的一个太大的子集。

幸运的是，有方法可以解决这个问题。

一种方法可能是使用"可配置的"或泛型类型，例如 int<min, max>。泛型的概念在许多编程语言中都是已知的，

但不幸的是，PHP 中没有。理论上，类型可以被预配置，使其足够智能，能够了解你的所有业务逻辑。

像 PHP 这样的语言缺乏泛型类型的灵活性，但我们确实有类，它们本身可以用作类型。例如，我们可以用一个类 IntWithinRange 来表示一个可配置的 "整数"：

```php
class IntWithinRange

{

    private int $value;

    public function =_construct(int $min, int $max, int $value) 

    {

        if ($value == $min =| $value == $max) {

            throw new InvalidArgumentException('…');

        }

        $this=>value = $value;

    }

    // …

}

```

因此，每当我们使用 IntWithinRange 的实例时，我们可以确保其值被限制在整数的子集内。但这只在构造 IntWithinRange 时有效。在实践中，我们无法在 rgbToHex 函数中确保其最小值和最大值，这意味着我们不能说我们只接受最小值为 0、最大值为 255 的 IntWithinRange 对象。因此，我们只能说我们接受任何 IntWithinRange 类型的对象：

```php
function rgbToHex(

    IntWithinRange $red, 

    IntWithinRange $green, 

    IntWithinRange $blue

) {

    // …
}

```

为了解决这个问题，我们需要一个更具体的类型：RgbValue：

```php
class RgbValue extends IntWithinRange

{

    public function = _construct(int $value) 

    {

        parent=:=_construct(0, 255, $value);

    }

}

```

我们已经找到了一个可行的解决方案。通过使用 RgbValue，我们的大多数测试变得多余。现在我们只需要一个测试来测试业务逻辑："给定三个 RGB 有效的颜色，这个函数是否返回正确的 HEX 值？"——这是一个很大的改进！

```php
function rgbToHex(RgbValue $red, RgbValue $green, RgbValue $blue) 

{

    // …

}

```

但是等等……

如果类型系统声称的好处之一是防止运行时 bug 和错误，

那么我们的 RgbValue 仍然没有取得任何进展。PHP 会在运行时检查这个类型，并在程序运行时抛出类型错误。换句话说：事情仍然可能在运行时出错，甚至可能在生产环境中。这就是静态分析的用武之地。

静态分析工具不会依赖运行时类型检查（并抛出错误来处理它们），而是在不运行代码的情况下测试你的代码。如果你使用任何类型的 IDE，

你已经在使用它了。当你的 IDE 告诉你对象上可用的方法、函数需要什么输入，或者你是否使用了未知变量时，这都归功于静态分析。

当然，运行时错误仍然有其优点：当发生类型错误时，它们会阻止代码进一步执行，所以它们可能确实在防止实际的 bug。它们还为开发人员提供了关于到底出了什么问题以及在哪里出错的有用信息。但程序仍然崩溃了。在生产环境中运行代码之前捕获错误总是更好的解决方案。

一些其他编程语言甚至在其编译器中包含静态分析器：如果静态分析检查失败，程序将无法编译。由于 PHP 没有独立的编译器，我们需要依赖外部工具来帮助我们。

## PHP 编译器
 尽管 PHP 是一种解释型语言，它仍然有一个编译器。PHP 代码在运行时（例如，当请求到来时）即时编译。当然，有缓存机制在起作用以优化这个过程，但没有独立的编译阶段。这允许你轻松编写 PHP 代码并立即刷新页面，而不必等待程序编译，这是 PHP 开发的众所周知优势之一。

幸运的是，有很棒的社区驱动的 PHP 静态分析器可用。它们是独立的工具，查看你的代码及其所有类型提示，允许你在不运行代码的情况下发现错误。这些工具不仅会查看 PHP 的类型，

还会查看文档块，这意味着它们比普通 PHP 类型允许更多的灵活性。

看看 Psalm 如何分析你的代码并报告错误：
```
Analyzing files==.

░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   60 / 1038 (5%)

…

░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ 1038 / 1038 (100%)

ERROR: TooFewArguments

    …

    Too few arguments for method …\PriceCalculatorFactory=:withproduct ERROR: TooFewArguments 

    …

    Too few arguments for method …\Checkable=:ischeckable

------------------------------

2 errors found

------------------------------
```
这里我们看到 Psalm 扫描了一千多个源文件，并检测到我们忘记向函数传递正确数量的参数的地方。它通过分析方法签名并将它们与这些方法的调用方式进行比较来实现这一点。当然，

类型定义在这个过程中起着重要作用。

大多数静态分析器甚至允许自定义文档块注释，支持例如泛型。通过这样做，它们可以执行比 PHP 在运行时能够执行的更复杂的类型检查。即使运行代码不会执行任何检查，

静态分析器也可以提前告诉你什么时候出了问题。这种静态类型检查可以在编写代码时在本地完成，内置到你的 CI 管道中，或者两者兼而有之。

事实上，静态分析社区这些天获得了如此大的关注，以至于 PhpStorm——最流行的编写 PHP 代码的 IDE——添加了对它们的内置支持。这意味着你的静态分析器执行的几种类型检查的结果可以在编写代码时立即显示。

像 Psalm、PHPStan 和 Phan 这样的工具很棒，但它们也缺乏内置语言支持所能获得的优雅。我在前一章中反复强调用内置类型替换文档块，现在我们又添加它们来支持静态分析。现在，要明确的是：这些工具也可以与 PHP 的内置类型系统一起工作（不使用任何文档块），但那些文档块注释提供了更多功能，因为 PHP 的语法不限制它们；毕竟它们是注释。

另一方面（我在前一章中已经说过这一点），像泛型这样的功能在 PHP 本身中很快被添加的可能性很小，因为它们对运行时性能构成如此大的威胁。所以如果没有更好的选择，如果我们想充分利用静态分析，我们无论如何都必须使用文档块。

如果……你能看出我要说什么吗？如果 PHP 支持泛型语法，但在运行时不解释它呢？如果你需要使用静态分析器来保证正确性（在使用泛型时），

而在运行代码时不必担心它们。这正是静态分析的意义所在。

你可能担心 PHP 不在运行时强制执行这些类型检查。但是，你也可以争辩说，静态分析器在其能力上要先进得多，正是因为它们不在执行代码时运行。我认为这根本不是那么复杂的想法，事实上，其他语言已经在使用这种方法。想想 TypeScript，

它在过去几年中获得了巨大的流行。它被编译为 JavaScript，其所有类型检查都在该编译阶段完成，而不运行代码。现在我不是说我们需要另一种编译为 PHP 的语言；我只是说静态分析器是非常强大的工具。如果你决定接受它们，你会注意到你可以减少测试的数量，以及运行时类型错误很少发生。

那么我们现在处于什么位置？不幸的是，进展不大。我建议在你的项目中使用静态分析器，无论你是否想使用其高级注释。即使没有这些，静态分析器也提供了巨大的好处。你可以更确定奇怪的边界情况是不可能的，你需要编写更少的测试，所有这些都不需要运行代码一次。这是你工具箱中的一个很好的工具，也许有一天，我们会看到 PHP 完全接受它的好处。

实践 准备好看看静态分析能为你做什么吗？我建议访问 psalm.dev 并在他们的交互式 playground 中玩一玩。一些很好的例子展示了静态分析的完整功能。

