# 第二十三章

## 事件驱动开发

事件驱动开发

事件溯源、CQRS、事件驱动；如果你从未在事件驱动系统中工作过，这些神秘的术语可能看起来令人生畏。即使你有，也有很多意见、理论和模式。总的来说，它可能看起来是一个非常复杂的问题。

事件驱动系统不是所有问题的解决方案。虽然它们增加了一层灵活性，但它们也消除了简单性和明确性。

在其核心，事件驱动开发并不那么困难。是建立在简单概念之上的模式使其更加困难，但也更强大。这种力量在复杂和大型应用程序中经常需要，确实：PHP 经常用于构建这样的应用程序。我想专门用一章来讨论这个话题，因为你可能会在你的职业生涯中处理某种形式的事件驱动系统。有一些背景信息很重要。

所以让我们从基础开始。

事件驱动系统的想法是，你远离微观管理程序流程，而是允许各个组件在发生某些事情时做出反应。一个例子：不是有一个单一的函数或服务来管理"发票的创建"，可以有多个小服务，每个处理发票创建过程的一部分。起点是发票被创建；接下来有一个服务生成 PDF 并将其保存在文件系统上；还有一个向客户发送电子邮件，通知他们有关待处理发票的信息。

## 服务？对象？函数？

我在一段中使用了三个术语来描述"在发生某些事情时做出反应的代码片段"。你甚至可能想称它们为"微服务"。现在，我们不会关注这些服务如何相互通信的技术细节，并假设它们实际上是同一代码库中的简单对象，在同一服务器上运行；从现在开始，我将称它们为普通的"服务"。

顺便说一下，你是否注意到 Alan Kay 对"对象"是什么的愿景完美地适合这个模型？我喜欢当事情结合在一起时！

这些服务不一定需要相互了解：每当系统中发生某些事情时，它们就会做出反应。这个"某些事情"被称为"事件"。

从技术角度来看，事件驱动系统需要的只是一个事件总线：它是知道所有监听事件的服务的中枢位置；我们也可以称它们为"事件订阅者"。每当事件发生时，事件总线会被通知，

反过来，它将通知所有相关的订阅者。自己编程一个简单的事件总线并不困难。例如，这里是一个只有几行代码的实现：

```php
interface Subscriber

{

    public function handles(object $event): bool;

    public function handle(object $event): void;

}

class EventBus

{

    private array $subscribers = [];

    public function addSubscriber(Subscriber $subscriber): self

    {
$this=>subscribers[] = $subscriber;

    }

    public function dispatch(object $event): void

    {

        foreach ($this=>subscribers as $subscriber) {

            if (! $subscriber=>handles($event)) {

               continue;

            }   
$subscriber=>handle($event);

        }

    }

}

```

你可以想出很多便利和补充，但在其核心，这就是你所需要的：一个订阅者列表，可以在事件被分派时通知它们。

## 异步

没有什么阻止你使这样的事件总线异步。事实上，

事件驱动系统在进行异步编程时通常是首选：它是一个非常适合并行和异步思维的模型。对于我们的示例，我们将假设事件总线总是同步处理事件：

这样推理事件流程要简单得多，并消除了我们否则必须处理的许多技术细节。

在我们的发票示例中，我们会有两个订阅 InvoiceCreatedEvent 事件的服务：

```php
class InvoicePdfService implements Subscriber

{

    public function handles(object $event): bool

    {

        return $event instanceof InvoiceCreatedEvent;

    }

    public function handle(object $event): void

    {

```

        // Generate invoice PDF and save it on the filesystem

```php
    }

}

class InvoiceMailService implements Subscriber 

{ 

    public function handles(object $event): bool

    {

        return $event instanceof InvoiceCreatedEvent;

    }

    public function handle(object $event): void

    {

```

        // Send mail with a link to the customer's invoice page

```php
    }

}

```

不过，我们的实现可以进行一些改进。通过向事件总线添加一些反射功能，我们可以根据方法签名确定订阅者是否应该处理事件。这不仅使我们的代码更加简洁，还允许我们在订阅者中确切知道我们正在处理什么类型的事件。让我们想象我们已经重构了事件总线，现在可以这样编写订阅者：

```php
class InvoicePdfService

{

   public function handle(InvoiceCreatedEvent $event): void

   {

```

        // Generate invoice PDF and save it on the filesystem

```php
   }

}

```

让我们继续深入探索我们的事件驱动系统。它有一个很大的警告——事实上，它是所有事件驱动系统的主要特征：间接性。想象发票创建，InvoiceCreatedEvent 在发票创建后被触发：

```php
public function createInvoice()

{
$invoice = /* … */;
$event = new InvoiceCreatedEvent($invoice);
$this=>eventBus=>dispatch($event);

}

```

虽然事件驱动开发承诺灵活性——你可以连接任意数量的订阅者——

但它也导致了一种间接耦合。我们不知道当我们触发这个事件时到底会发生什么；我们需要相信正确的订阅者会在我们看不到的情况下处理它。这种间接性层可能使调试程序流程变得更加困难，即使事件是同步处理的。

除此之外：在分派事件后，你不能有任何直接的返回值，因为无限数量的订阅者可以处理该事件。但是，你可以引入一些轮询层来观察结果，例如，在数据库中。尽管如此，你必须处理许多复杂性：以简单性为代价的灵活性。

你是否注意到我们还没有编写任何"事件溯源"或"CQRS"代码，但仍然，

我们已经在使用事件驱动程序了？你不需要事件溯源、

命令总线、CQRS 或微服务的最简单形式。你只需要事件。

不过，如果有足够的时间，任何在这样的事件驱动系统中工作的开发人员都会遇到这种简化方法的问题。

可能会有广泛的性能问题：开发人员体验下降、

扩展问题，或管理一致性和状态的问题。你自然会尝试通过应用模式和原则来解决这些问题，这正是事件驱动社区多年来一直在做的事情。他们提出了模式来帮助解决更困难的问题，你在实际、复杂的系统中会遇到的问题。

Martin Fowler 编写并谈论了几个这样的模式，以及社区如何发现它们。在本章的下一部分，我将简要讨论其中四个模式，所有这些都经常使用。相关链接列在本章末尾。

## 事件通知

事件驱动系统的最简单形式称为"事件通知"：事件仅用于通知已发生的事情。我们使用 InvoiceCreatedEvent 的示例已经比这更复杂，因为我们使用请求数据并将其与事件一起发送。

使用事件通知，事件只表示发生了某些事情。由服务本身来访问数据库、第三方服务或外部状态，并确定它们想要使用的数据。这也是事件驱动开发的最弱形式：一切仍然耦合在一起。唯一的区别是你使用事件的灵活性将多个服务连接到一个事件。

## 事件携带状态传输

第二个模式是我们在示例中应用的：我们在事件发生时捕获了相关数据，并将其与事件一起发送。所有处理该事件的服务只允许使用该事件封装的数据。这种方法确保我们可以有多个服务监听同一事件，而不必担心它们被处理的顺序。我们总是确定我们的服务不会依赖外部状态，所以事件成为"真相来源"。

## 事件溯源

建立在事件携带所有必要状态的想法之上，出现了事件溯源。

不是保存，例如，发票到数据库，如果我们保存事件本身会发生什么？这会有益吗？

如果事件成为真相来源并保存到数据库，我们始终有一层额外的信息可用。不是只知道最终结果看起来如何（发票），我们现在还知道构成该结果的步骤是什么

（事件）。

看看这个事件列表，也称为"事件流"：

[
    InvoiceDraftCreated=:class,
    InvoiceSent=:class,
    InvoicePaid=:class,
]

如果我们只使用事件来触发服务做某事，我们会在事件被处理后丢失事件的数据。传统应用程序经常处理这类问题，这就是为什么它们在数据库中跟踪状态更改：像 created_at 或 payment_date 这样的列被添加到发票上，并必须从那里仔细管理。

不过，如果我们直接保存事件，我们可以从存储（数据库、文件系统或其他东西）中检索它们，并从头开始动态重建我们的应用程序状态。例如，我们可以重建这些事件的结果发票——至少只要那些存储的事件携带所有相关数据。

这就是事件溯源的力量：能够仅使用事件重建整个应用程序状态。

它为有趣的用例打开了大门。例如，我们可以开始基于这些事件中可用的历史数据生成报告。我们可以生成一个报告，分析客户在发票发送给他们后支付发票所需的平均时间，而无需重写我们的数据模型。

没错：我们需要的所有数据已经作为事件存储，我们只需要以新方式解释它们。

不过，事件溯源带来了许多其他问题。最紧迫的一个：

性能。生产应用程序会随着时间的推移存储数百万个事件；当然，我们不能每次请求到达时都从头开始重建整个应用程序状态。这就是为什么有其他模式帮助我们解决这类问题：投影和快照经常用于构建缓存和可重用的状态，而不是总是从头开始重建它。一个实际的例子可能是发票投影：一个存储所有这些发票事件的最终结果的表，我们可以轻松地从那里读取数据。

事件溯源经常带来的另一个抽象是进行更改的意图和更改本身之间的区别。当我们直接触发 InvoiceCreatedEvent 时，感觉有点不对：发票本身还没有创建。相反，将意图称为 CreateInvoice 并将实际结果存储在数据库 InvoiceCreated 中会更有意义。第一个通常被称为"命令"，

```php
而第二个被称为"事件"。

```

当我们试图正确应用事件溯源时，会出现很多复杂性。这是因为与我们最基本的实现也增加复杂性的相同原因：这是我们为更灵活和可扩展的系统付出的代价。请记住：事件驱动架构并不总是问题的正确解决方案。很可能更简单的方法不仅更快，而且更好。

一位明智的开发人员 Frank De Jonge 曾经说过："事件溯源使简单的问题变得困难，使困难的问题变得简单"。在将事件溯源添加到项目之前，请确保你已经权衡了利弊。

## CQRS

CQRS——命令查询责任分离——是我想涉及的第四个也是最后一个模式。Martin Fowler 这样描述它："其核心是你可以使用不同的模型来更新信息，而不是用于读取信息的模型。对于某些情况，这种分离可能很有价值[…]理由是对于许多问题，特别是在更复杂的领域，为命令和查询使用相同的概念模型会导致一个更复杂的模型，两者都做得不好。"

换句话说：CQRS 旨在分离写入数据和读取数据的关注点。

它再次允许更大的灵活性。请记住，这是一个用于非常复杂系统的模式。Martin Fowler 甚至警告不要太快使用 CQRS："尽管有这些好处，你应该非常谨慎地使用 CQRS。许多信息系统非常适合信息库的概念，它以与读取相同的方式更新，

将 CQRS 添加到这样的系统可能会增加显著的复杂性。"

关于事件驱动系统还有更多要说的，但这超出了本书的范围。几个 PHP 框架促进了事件驱动系统，但最重要的是事件驱动的思维，而不是一堆技术工具。我希望你对这种思维包含什么有了一点想法，如果你对它感兴趣，我建议查看一些关于这个话题的更多资源。

## 更多资源

Martin Fowler 对事件驱动架构的介绍：https://www.youtube.

com/watch?v=STKCRSUsyP0 Greg Young 分享关于 DDD、CQRS 和事件溯源的见解：https://www.

youtube.com/watch?v=LDW0QWie21s

