# 第十七章

## JIT

PHP 8 中的 JIT 有很多炒作。有人说它将彻底改变 PHP 的格局。在本章中，我们将讨论 JIT 是什么，它如何显著影响 PHP 的性能，并查看一些实际基准测试。

## 什么是 JIT？

首先："JIT"代表"just in time"（即时）。它的全名是"即时编译器"。你可能还记得，在第 4 章中，我解释了编译语言和解释语言之间的区别：PHP 属于后者。那么，这个编译器是从哪里来的？嗯，事实上：PHP 有一个编译器，但它不像你在编译语言中看到的那样：没有独立的步骤来运行它，它不会生成二进制文件。编译器是 PHP 运行时引擎的一部分：PHP 代码仍然需要被编译——翻译——为机器代码；它只是在运行 PHP 代码时即时发生。

JIT 编译器利用像这样的解释语言：它在运行时查看代码并尝试识别所谓的"热点"（比其他部分执行更频繁的部分）。JIT 将获取该源代码并即时编译为更优化的、对机器友好的代码块，可以运行它。有趣的是，这只能在解释语言中实现，因为完全预先编译的程序无法再改变。尝试识别热点的机制称为"监视器"：它将查看代码，并在运行时监视它。当它检测到执行多次的部分时，它会将它们标记为"温"或"热"。然后它可以将热点编译为优化的代码块。你可以想象这个话题还有很多复杂性，但本书的目标不是深入解释 JIT 编译器。相反，它是教你如何在 PHP 中使用它以及何时使用它。

虽然这在理论上听起来很棒，但有一些注意事项。首先：监视代码和生成 JIT 代码也会带来性能成本。幸运的是，从 JIT 获得的好处超过了这个成本。至少，在某些情况下。

第二个问题更重要：在服务 Web 请求的常规 MVC 应用程序中，没有多少热点可以优化。当 JIT 还处于早期阶段时，PHP 社区中分享了一个流行的例子。它显示了使用和不使用 JIT 生成的分形。JIT 版本显著——十倍——更快。但让我们诚实地说：我们在 PHP 应用程序中很少生成分形图像。

即使在框架级别，也很少有代码从优化的 JIT 版本中受益。Web 应用程序中的主要性能瓶颈不是代码本身；它是 I/O 操作，如发送和接收请求、从文件系统读取数据，或与数据库服务器通信。

我们此时正在推测 JIT 的性能。让我们看看一些实际的基准测试。我拿了一个 Laravel 项目及其生产数据库，并决定对其进行基准测试。

## 实际基准测试

让我们先设置场景。这些基准测试在我的本地机器上运行。因此，它们对绝对性能提升没有任何说明；在这里，我只对
JIT 对实际代码的相对影响做出结论感兴趣。

我将运行 PHP FPM，配置为生成 20 个子进程，并且我将始终确保一次只运行 20 个并发请求，以消除 FPM 级别的任何额外性能影响。发送这些请求是使用以下命令完成的，

使用 ApacheBench：

ab -n 100 -c 20 -l localhost:8000

## JIT 设置

项目就位后，让我们配置 JIT 本身。JIT 通过在 php.ini 中指定 opcache.jit_buffer_size 选项来启用。如果排除此指令，默认值设置为 0，JIT 将不会运行。

opcache.jit_buffer_size=100M 

你还想设置一个 JIT 模式，这将确定 JIT 如何监视和响应代码的热点。你需要使用 opcache.jit 选项。它的默认值设置为 tracing，但你也可以将其设置为 function：

opcache.jit=function

; opcache.jit=tracing

tracing 或 function 模式将确定 JIT 如何工作。区别在于 function JIT 只会在单个函数的上下文中监视和编译代码，而 tracing JIT 可以跨越这些边界。在我们的实际基准测试中，我将比较两种模式。所以让我们开始基准测试！

## 建立基线

首先，最好确定 JIT 是否正常工作。我们从 RFC 中知道它对计算分形有显著影响。所以让我们从那个例子开始。我从 RFC 复制了 mandelbrot 示例，并通过我将运行下一个基准测试的相同 HTTP 应用程序访问它：

```php
public function index()

{

    for ($y = -39; $y < 39; $y=+) {

        printf("\n");

        for ($x = -39; $x < 39; $x=+) {
$i = $this=>mandelbrot(
$x / 40.0,
$y / 40.0

            );

            if ($i == 0) {

                printf("*");

            } else {

                printf(" ");

            }

        }

    }

    printf("\n");

}

private function mandelbrot($x, $y)

{
$cr = $y - 0.5;
$ci = $x;
$zi = 0.0;
$zr = 0.0;
$i = 0;

    while (1) {
$i=+;
$temp = $zr * $zi;
$zr2 = $zr * $zr;
$zi2 = $zi * $zi;
$zr = $zr2 - $zi2 + $cr;
$zi = $temp + $temp + $ci;

        if ($zi2 + $zr2 > 16) {

            return $i;

        }

        if ($i > 5000) {

            return 0;

        }

    }
}
```

运行 ab 几百个请求后，我们可以看到结果：

                                      requests/second (more is better)

Mandelbrot without JIT                                            3.60 Mandelbrot with tracing JIT                                      41.36 太好了，看起来 JIT 正在工作！甚至有十倍的性能提升！

如果你想验证 JIT 是否正在运行，你可以使用 opcache_get_status()，它有一个 jit 条目，列出了所有相关信息：

```php
print_r(opcache_get_status()['jit']);

```

// array:7 [

//   "enabled" => true

//   "on" => true

//   "kind" => 5

//   "opt_level" => 4

//   "opt_flags" => 6

//   "buffer_size" => 104857584

//   "buffer_free" => 104478688

// ]

验证它按预期工作后，让我们继续我们的第一个实际比较。
我们将比较在没有 JIT、使用 function JIT 和使用 tracing JIT 的情况下运行我们的代码，两者都使用 100MB 内存。我们将进行基准测试的页面显示帖子概览，所以有一些递归发生。我们还接触了 Laravel 的几个核心部分：路由、依赖容器以及 ORM 层。

                                      requests/second (more is better)

No JIT                                                           63.56 Function JIT                                                     66.32 Tracing JIT                                                      69.45 

这里我们看到结果：启用 JIT 只有轻微的改进。事实上，重复运行基准测试，结果每次都略有不同：我甚至看到过 JIT 启用的运行比非 JIT 版本表现更差的情况。在得出结论之前，让我们提高内存缓冲区限制。我们将给 JIT 更多的呼吸空间，使用 500MB 内存而不是 100MB。

                                      requests/second (more is better)

No JIT                                                           71.69 Function JIT                                                     72.82 Tracing JIT                                                      70.11

这里我们有一个 JIT 表现更差的情况。就像我在本章开头说的：我想测量 JIT 对实际 Web 项目的相对影响。从这些测试中可以清楚地看出，有时可能会有好处，但绝不像我们开始时的分形示例那样明显。我承认我并不感到惊讶。

就像我之前写的：在实际应用程序中，很少有热点代码可以优化。

我们很少做类似分形的计算。

所以我说不需要 JIT 吗？不完全是这样。我认为 JIT 可以为 PHP 开辟新领域：复杂计算确实从 JIT 代码中受益的领域。我在考虑机器学习和解析器之类的东西。JIT 可能为 PHP 社区提供尚不存在的机会，但在这一点上，不确定地说任何事情。例如，有一个名为 nikic/php-parser 的包——一个 PHP 实现，可以获取 PHP 代码并解析为结构化数据。这个包实际上被像 Psalm 这样的静态分析工具使用，事实证明这个包确实从 JIT 中受益匪浅。

所以即使在今天，已经有优势了，只是在运行 Web 应用程序时没有。

## 需要维护的复杂性

将 JIT 添加到 PHP 核心也带来了额外的维护成本。因为 JIT 生成机器代码，你可以想象对于高级程序员来说，理解它是复杂的材料。假设 JIT 编译器中有一个 bug。为此，你需要一个知道如何修复它的开发人员。在这个 JIT 的情况下，Dmitry Stogov 在它上面做了大部分编程，只有少数人理解它是如何工作的。

由于今天只有少数人能够维护这样的代码库，JIT 编译器是否可以正确维护的问题似乎是合理的。当然，人们可以学习编译器如何工作，但这仍然是一个复杂的问题。
我不认为这应该是放弃 JIT 的理由，但维护成本仍然应该仔细考虑。首先，由维护代码的人和用户社区，他们也应该意识到一些 bug 修复或版本更新可能需要比我们现在习惯的更长的时间。

## 你想要它吗？

如果你认为 JIT 为你的 Web 应用程序提供的短期好处很少，我会说你是对的。很明显，它的影响充其量是最小的。

尽管如此，我们应该记住，JIT 可以为 PHP 的成长开辟许多可能性，无论是作为 Web 语言还是更通用的语言。所以需要回答的问题：这可能是值得今天投资的光明未来吗？

时间会证明一切。

